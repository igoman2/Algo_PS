Implement a simple meeting assistant. A list of strings, events[n], in the form "<person name> <action> «start> <end>" is provided where person name performs action from start to end, both inclusive.
Times are formatted HH:MM. Find the earliest time in the day, from "00:00" to "23:59", when all people mentioned in at least one event are available for a meeting of k minutes. Report the answer as "HH:MM" or the string "-1" if it is not possible.
Example:
12:30 13:59"]
k= 60
events = ( "Alex sleep 00:00 08:00", "Sam sleep 07:00 13:00", "Alex lunch
Alex is not available until 8:00. After that, Sam is not available until 13:00.
Then Alex is busy until 13:59. Return the earliest time they are both available, "14:00".
Function Description
Complete the function getEarliestMeetTime in the editor below.
getEarliestMeetTime takes the following arguments:
string events[n]: event descriptors int k: meeting duration
Returns
string: the earliest time for the meeting or "-1" if it is not possible
Constraints
• 1 5ns 105
• 1 ≤ length of events il ≤ 40
• 1 sks 1440
• It is guaranteed that the number of people is less than 5000.
• It is guaranteed that no person's events overlap.


'use strict';

const fs = require('fs');

process.stdin.resume();
process.stdin.setEncoding('utf-8');

let inputString = '';
let currentLine = 0;

process.stdin.on('data', function(inputStdin) {
    inputString += inputStdin;
});

process.stdin.on('end', function() {
    inputString = inputString.split('\n');

    main();
});

function readLine() {
    return inputString[currentLine++];
}



/*
 * Complete the 'getEarliestMeetTime' function below.
 *
 * The function is expected to return a STRING.
 * The function accepts following parameters:
 *  1. STRING_ARRAY events
 *  2. INTEGER k
 */

/**
 * 시간을 분으로 계산한 값을 리턴
 */
function toMinutes(time) {
    let [hours, minutes] = time.split(':').map((t) => Number(t))
    return hours * 60 + minutes
}

/**
 * HH:MM 형태로 시간을 포매팅
 */
function toHHMM(minutes){
    let hours = Math.floor(minutes / 60)
    minutes = minutes % 60

    return `${String(hours).padStart(2, 0)}:${String(minutes).padStart(2, 0)}`
}

/**
 * 전 인원에 대해 가능한지 검사하는 함수
 */
function checkAvailability(start, end, timeTable) {
    for(let name in timeTable){
        for(let [unavailableStart, unavailableEnd] of timeTable[name]){
            if ((start >= unavailableStart && start <= unavailableEnd) || 
                (end >= unavailableStart && end <= unavailableEnd) ||
                (start <= unavailableStart && end >= unavailableEnd)) {
                return false;
            }
        }
    }
    
    return true
}

function getEarliestMeetTime(events, k) {
    // 이용 불가능한 시간 map
    const disableTimes = {}
    for(let event of events){
        let [name, str, start, end] = event.split(' ')
        
        if(!disableTimes[name]){
            disableTimes[name] = []
        }
        
        disableTimes[name].push([toMinutes(start), toMinutes(end)])
    }
    
    // k분은 최소로 필요하기 때문에 빼줘도 결과에 영향이 없음.
    for(let i=0; i <= 1400 - k; i++){
        if(checkAvailability(i, i + k, disableTimes)){
            return toHHMM(i)
        }
    }
    
    return "-1"
}

function main() {
    const ws = fs.createWriteStream(process.env.OUTPUT_PATH);

    const eventsCount = parseInt(readLine().trim(), 10);

    let events = [];

    for (let i = 0; i < eventsCount; i++) {
        const eventsItem = readLine();
        events.push(eventsItem);
    }

    const k = parseInt(readLine().trim(), 10);

    const result = getEarliestMeetTime(events, k);

    ws.write(result + '\n');

    ws.end();
}
