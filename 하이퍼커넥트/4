To implement the ControlledPromise class, you can create a promise internally, and control the resolution of this promise using the resolve and reject functions.



class ControlledPromise<T> {
  private resolve!: (value: T) => void;
  private reject!: (message?: any) => void;
  private promise: Promise<T>;
  
  constructor() {
    this.promise = new Promise<T>((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject
    })
  }
  
  finish(value: T) {
    this.resolve(value)
  }
  
  wait(){
    return this.promise
  }
}

// Example usage
/*
const controlledPromise = new ControlledPromise<string>();

setTimeout(() => {
  controlledPromise.finish('hello');
}, 1000);

(async() => {
  const value = await controlledPromise.wait();
  console.log(value); // hello
})();
*/


// non-assertion은 타입스크립트 에러때문에 발생
// 이 에러는 TypeScript의 strictPropertyInitialization 설정 때문에 발생합니다. 이 설정은 클래스의 속성이 생성자에서 초기화되지 않았을 때 에러를 발생시킵니다.
// resolve와 reject는 생성자 내에서 초기화되기 때문에 이를 TypeScript에 알려주기 위해 ! (non-null assertion operator)를 사용해야 합니다.
